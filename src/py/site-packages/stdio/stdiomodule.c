/*----------------------------------------------------------------------------
//
//       Copyright (C) 2016-2023 Frank Eskesen.
//
//       This file is free content, distributed under creative commons CC0,
//       explicitly released into the Public Domain.
//       (See accompanying html file LICENSE.ZERO or the original contained
//       within https://creativecommons.org/publicdomain/zero/1.0/legalcode)
//
******************************************************************************
**
** Title-
**       stdiomodule.c
**
** Purpose-
**       Python 'stdio' module: Provides 'getchar' and 'putchar'
**
** Last change date-
**       2023/08/12
**
*****************************************************************************/
#define PY_SSIZE_T_CLEAN            /* (Python 3.9 recommendation)          */
#include <Python.h>

#include <stdio.h>                  /* For getchar, putchar                 */
#include <termios.h>                /* For termios                          */
#include <unistd.h>                 /* For atexit, read, ...                */

/*****************************************************************************
** ATEXIT
**
** The original termios settings are restored when the main thread exits
** since this exit can occur while chget is waiting for a character.
**
*****************************************************************************/
static struct termios  oldattr;     /* Set ONCE, restored atexit */
static void handler(void) {         /* The atexit handler */
    tcsetattr(STDIN_FILENO, TCSANOW, &oldattr); /* Restore termios settings */
}

/*  Reads one character from stdin, does not echo.                          */
static PyObject* stdio_getchar(PyObject *self, PyObject *args)
{
    int ch= -1;
    Py_BEGIN_ALLOW_THREADS
    struct termios newattr = oldattr;
    newattr.c_lflag &= ~( ICANON | ECHO ); /* NOT (cononical or echo) */
    newattr.c_cc[VMIN] = 0;         /* No minimum character count */
    newattr.c_cc[VTIME] = 0;        /* Polling read, no timeout */
    tcsetattr(STDIN_FILENO, TCSANOW, &newattr);
    while( ch <= 0 ) {
        char buffer[8];
        ssize_t L= read(STDIN_FILENO, buffer, 1);
        if( L > 0 )
            ch= buffer[0];
        else {
            newattr.c_cc[VTIME] = 10; /* Set timeout (tenths of a second) */
            tcsetattr(STDIN_FILENO, TCSANOW, &newattr);
        }
    }

    tcsetattr(STDIN_FILENO, TCSANOW, &oldattr);
    if( ch == 0x007f )              /* Nasty surprise */
        ch = '\b';

    Py_END_ALLOW_THREADS
    return PyUnicode_FromOrdinal(ch);
}

/*  Just like print("%s" % (s[0])) where s must be a string.                */
/*  Writes the first character of a string to stdout, just because we can.  */
static PyObject* stdio_putchar(PyObject *self, PyObject *args)
{
    const char* s;
    if( !PyArg_ParseTuple(args, "s", &s) )
        return NULL;

    int c = s[0];
    if( c == '\0' )
        c = ' ';

    putchar(c);
    fflush(stdout);

    Py_RETURN_NONE;
}

static PyMethodDef StdioMethods[] =
{   {"getchar", stdio_getchar, METH_NOARGS
    , "Reads a character from standard input without echoing it."}
,   {"putchar", stdio_putchar, METH_VARARGS
    , "Writes a character onto standard ouput"}
,   {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef stdiomodule = {
    PyModuleDef_HEAD_INIT,
    "stdio",   /* name of module */
    NULL,      /* module documentation, may be NULL */
    -1,        /* size of per-interpreter state of the module, or -1 if the
                  module keeps state in global variables. */
    StdioMethods
};

PyMODINIT_FUNC PyInit_stdio(void)
{
    tcgetattr(STDIN_FILENO, &oldattr); /* Initial STDIN attributes */
    atexit(handler);                /* Restore initial attributes at exit */

    return PyModule_Create(&stdiomodule);
}
