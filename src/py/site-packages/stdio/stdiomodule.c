/*----------------------------------------------------------------------------
//
//       Copyright (C) 2016-2021 Frank Eskesen.
//
//       This file is free content, distributed under creative commons CC0,
//       explicitly released into the Public Domain.
//       (See accompanying html file LICENSE.ZERO or the original contained
//       within https://creativecommons.org/publicdomain/zero/1.0/legalcode)
//
******************************************************************************
**
** Title-
**       stdiomodule.c
**
** Purpose-
**       Python 'stdio' module: Provides 'getch' and 'putch'
**
** Last change date-
**       2021/04/02
**
*****************************************************************************/
#include <Python.h>

#include <termios.h>
#include <unistd.h>
#include <stdio.h>

/*****************************************************************************
** ATEXIT
**
** The original termios settings are restired when the main thread exits
** since this exit can occur while chget is waiting for a character.
**
*****************************************************************************/
static int             registerme = 1; /* Protected by python GIL */
static struct termios  oldattr;     /* Set ONCE, restored atexit */
static void handler(void) {         /* The atexit handler */
    tcsetattr(STDIN_FILENO, TCSANOW, &oldattr); /* Restore termios settings */
}

/*  Reads one character from stdin, does not echo.                          */
static int chget(void)
{
    if( registerme ) {              /* Registration protected by python GIL */
        tcgetattr(STDIN_FILENO, &oldattr);
        atexit(handler);
        registerme = 0;
    }

    int ch= -1;
    Py_BEGIN_ALLOW_THREADS
    struct termios newattr = oldattr;
    newattr.c_lflag &= ~( ICANON | ECHO ); /* NOT (cononical or echo) */
    newattr.c_cc[VMIN] = 0;         /* No minimum character count */
    newattr.c_cc[VTIME] = 0;        /* Polling read, no timeout */
    tcsetattr(STDIN_FILENO, TCSANOW, &newattr);
    while( ch <= 0 ) {
      char buffer[8];
      ssize_t L= read(STDIN_FILENO, buffer, 1);
      if( L > 0 )
        ch= buffer[0];
      else {
        newattr.c_cc[VTIME] = 10;   /* Set timeout (tenths of a second) */
        tcsetattr(STDIN_FILENO, TCSANOW, &newattr);
      }
    }

    tcsetattr(STDIN_FILENO, TCSANOW, &oldattr);
    if( ch == 0x007f )              /* Nasty surprise */
        ch = '\b';

    Py_END_ALLOW_THREADS
    return ch;
}

static PyObject* stdio_getch(PyObject *self, PyObject *args)
{
    int ch = chget();
    return PyUnicode_FromOrdinal(ch);
}

/*  Just like print("%s" % (s[0])) where s must be a string.                */
/*  Writes the first character of a string to stdout, just because we can.  */
static PyObject* stdio_putch(PyObject *self, PyObject *args)
{
    const char* s;
    if( !PyArg_ParseTuple(args, "s", &s) )
        return NULL;

    int c = s[0];
    if( c == '\0' )
        c = ' ';

    putchar(c);
    fflush(stdout);

    Py_RETURN_NONE;
}

static PyMethodDef StdioMethods[] = {
    {"getch", stdio_getch, METH_NOARGS,  "Reads a character from standard input, not echoing it."},
    {"putch", stdio_putch, METH_VARARGS, "Writes a character onto standard ouput"},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef stdiomodule = {
    PyModuleDef_HEAD_INIT,
    "stdio",   /* name of module */
    NULL,      /* module documentation, may be NULL */
    -1,        /* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
    StdioMethods
};

PyMODINIT_FUNC PyInit_stdio(void)
{
    return PyModule_Create(&stdiomodule);
}
