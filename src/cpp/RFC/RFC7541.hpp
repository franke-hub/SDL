//----------------------------------------------------------------------------
//
//       Copyright (C) 2023 Frank Eskesen.
//
//       This file is free content, distributed under the GNU General
//       Public License, version 3.0.
//       (See accompanying file LICENSE.GPL-3.0 or the original
//       contained within https://www.gnu.org/licenses/gpl-3.0.en.html)
//
//----------------------------------------------------------------------------
//
// Title-
//       RFC7541.hpp
//
// Purpose-
//       RFC7541, HTTP/2 HPACK compression helper file
//
// Last change date-
//       2023/10/13
//
// Implementation notes-
//       This file is included by and considered part of RFC7541.cpp
//       It should not be included by any other file.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Namespace: RFC7541, HTTP/2 HPACK compression
//----------------------------------------------------------------------------
namespace RFC7541 {

//----------------------------------------------------------------------------
// Constants for parameterization
//----------------------------------------------------------------------------
enum                                // Table dimensions
{  DECODE_INDEX_DIM= 21             // Decoding table size
,  DECODE_TABLE_DIM= 256            // Decoding table size
,  ENCODE_TABLE_DIM= 256            // Encoding table size
}; // Table dimensions

//----------------------------------------------------------------------------
//
// Struct-
//       Bits7541
//
// Purpose-
//       RFC7541 Huffman decoding bit length vector
//
//----------------------------------------------------------------------------
struct Bits7541 {                   // RFC7541 Huffman decoding bit lengths
uint16_t               min_index;   // Minimum index
uint16_t               bits;        // Encoding length, in bits
uint32_t               min_encode;  // Minimum encoded value
uint32_t               max_encode;  // Maximum encoded value
}; // struct Bits7541

//----------------------------------------------------------------------------
//
// Struct-
//       Huff7541
//
// Purpose-
//       RFC7541 Huffman encoding/decoding item
//
//----------------------------------------------------------------------------
struct Huff7541 {                   // RFC7541 Huffman encoding/decoding item
uint16_t               decode;      // The encoded character
uint16_t               bits;        // Encoding length, in bits
uint32_t               encode;      // The character encoding
}; // struct Huff7541

//----------------------------------------------------------------------------
//
// Data area-
//       decode_index
//       decode_table
//
// Purpose-
//       RFC7541 Huffman decoding data areas
//
//----------------------------------------------------------------------------
static const Bits7541  decode_index[DECODE_INDEX_DIM]=
{  {  0,  5, 0x0000'0000, 0x0000'0009} // [ 0]  10 code points
,  { 10,  6, 0x0000'0014, 0x0000'002D} // [ 1]  26
,  { 36,  7, 0x0000'005C, 0x0000'007B} // [ 2]  32
,  { 68,  8, 0x0000'00F8, 0x0000'00FD} // [ 3]   6
,  { 74, 10, 0x0000'03F8, 0x0000'03FC} // [ 4]   5
,  { 79, 11, 0x0000'07FA, 0x0000'07FC} // [ 5]   3
,  { 82, 12, 0x0000'0FFA, 0x0000'0FFB} // [ 6]   2
,  { 84, 13, 0x0000'1FF8, 0x0000'1FFD} // [ 7]   6
,  { 90, 14, 0x0000'3FFC, 0x0000'3FFD} // [ 8]   2
,  { 92, 15, 0x0000'7FFC, 0x0000'7FFE} // [ 9]   3
,  { 95, 19, 0x0007'FFF0, 0x0007'FFF2} // [10]   3
,  { 98, 20, 0x000F'FFE6, 0x000F'FFED} // [11]   8
,  {106, 21, 0x001F'FFDC, 0x001F'FFE8} // [12]  13
,  {119, 22, 0x003F'FFD2, 0x003F'FFEB} // [13]  26
,  {145, 23, 0x007F'FFD8, 0x007F'FFF4} // [14]  29
,  {174, 24, 0x00FF'FFEA, 0x00FF'FFF5} // [15]  12
,  {186, 25, 0x01FF'FFEC, 0x01FF'FFEF} // [16]   4
,  {190, 26, 0x03FF'FFE0, 0x03FF'FFEE} // [17]  15
,  {205, 27, 0x07FF'FFDE, 0x07FF'FFF0} // [18]  19
,  {224, 28, 0x0FFF'FFE2, 0x0FFF'FFFE} // [19]  29
,  {253, 30, 0x3FFF'FFFC, 0x3FFF'FFFE} // [20]   4
}; // decode_index

//----------------------------------------------------------------------------
// Decoding table
static const Huff7541    decode_table[DECODE_TABLE_DIM]=
{  { 48,  5, 0x0000'0000}           // [0x30] '0'    [  0] 00000
,  { 49,  5, 0x0000'0001}           // [0x31] '1'    [  1]
,  { 50,  5, 0x0000'0002}           // [0x32] '2'    [  2]
,  { 97,  5, 0x0000'0003}           // [0x61] 'a'    [  3]
,  { 99,  5, 0x0000'0004}           // [0x63] 'c'    [  4]
,  {101,  5, 0x0000'0005}           // [0x65] 'e'    [  5]
,  {105,  5, 0x0000'0006}           // [0x69] 'i'    [  6]
,  {111,  5, 0x0000'0007}           // [0x6F] 'o'    [  7]
,  {115,  5, 0x0000'0008}           // [0x73] 's'    [  8]
,  {116,  5, 0x0000'0009}           // [0x74] 't'    [  9] 01001
,  { 32,  6, 0x0000'0014}           // [0x20] ' '    [ 10] 010100
,  { 37,  6, 0x0000'0015}           // [0x25] '%'    [ 11]
,  { 45,  6, 0x0000'0016}           // [0x2D] '-'    [ 12]
,  { 46,  6, 0x0000'0017}           // [0x2E] '.'    [ 13]
,  { 47,  6, 0x0000'0018}           // [0x2F] '/'    [ 14]
,  { 51,  6, 0x0000'0019}           // [0x33] '3'    [ 15]
,  { 52,  6, 0x0000'001A}           // [0x34] '4'    [ 16]
,  { 53,  6, 0x0000'001B}           // [0x35] '5'    [ 17]
,  { 54,  6, 0x0000'001C}           // [0x36] '6'    [ 18]
,  { 55,  6, 0x0000'001D}           // [0x37] '7'    [ 19]
,  { 56,  6, 0x0000'001E}           // [0x38] '8'    [ 20]
,  { 57,  6, 0x0000'001F}           // [0x39] '9'    [ 21]
,  { 61,  6, 0x0000'0020}           // [0x3D] '='    [ 22]
,  { 65,  6, 0x0000'0021}           // [0x41] 'A'    [ 23]
,  { 95,  6, 0x0000'0022}           // [0x5F] '_'    [ 24]
,  { 98,  6, 0x0000'0023}           // [0x62] 'b'    [ 25]
,  {100,  6, 0x0000'0024}           // [0x64] 'd'    [ 26]
,  {102,  6, 0x0000'0025}           // [0x66] 'f'    [ 27]
,  {103,  6, 0x0000'0026}           // [0x67] 'g'    [ 28]
,  {104,  6, 0x0000'0027}           // [0x68] 'h'    [ 29]
,  {108,  6, 0x0000'0028}           // [0x6C] 'l'    [ 30]
,  {109,  6, 0x0000'0029}           // [0x6D] 'm'    [ 31]
,  {110,  6, 0x0000'002A}           // [0x6E] 'n'    [ 32]
,  {112,  6, 0x0000'002B}           // [0x70] 'p'    [ 33]
,  {114,  6, 0x0000'002C}           // [0x72] 'r'    [ 34]
,  {117,  6, 0x0000'002D}           // [0x75] 'u'    [ 35] 101101
,  { 58,  7, 0x0000'005C}           // [0x3A] ':'    [ 36] 1011100
,  { 66,  7, 0x0000'005D}           // [0x42] 'B'    [ 37]
,  { 67,  7, 0x0000'005E}           // [0x43] 'C'    [ 38]
,  { 68,  7, 0x0000'005F}           // [0x44] 'D'    [ 39]
,  { 69,  7, 0x0000'0060}           // [0x45] 'E'    [ 40]
,  { 70,  7, 0x0000'0061}           // [0x46] 'F'    [ 41]
,  { 71,  7, 0x0000'0062}           // [0x47] 'G'    [ 42]
,  { 72,  7, 0x0000'0063}           // [0x48] 'H'    [ 43]
,  { 73,  7, 0x0000'0064}           // [0x49] 'I'    [ 44]
,  { 74,  7, 0x0000'0065}           // [0x4A] 'J'    [ 45]
,  { 75,  7, 0x0000'0066}           // [0x4B] 'K'    [ 46]
,  { 76,  7, 0x0000'0067}           // [0x4C] 'L'    [ 47]
,  { 77,  7, 0x0000'0068}           // [0x4D] 'M'    [ 48]
,  { 78,  7, 0x0000'0069}           // [0x4E] 'N'    [ 49]
,  { 79,  7, 0x0000'006A}           // [0x4F] 'O'    [ 50]
,  { 80,  7, 0x0000'006B}           // [0x50] 'P'    [ 51]
,  { 81,  7, 0x0000'006C}           // [0x51] 'Q'    [ 52]
,  { 82,  7, 0x0000'006D}           // [0x52] 'R'    [ 53]
,  { 83,  7, 0x0000'006E}           // [0x53] 'S'    [ 54]
,  { 84,  7, 0x0000'006F}           // [0x54] 'T'    [ 55]
,  { 85,  7, 0x0000'0070}           // [0x55] 'U'    [ 56]
,  { 86,  7, 0x0000'0071}           // [0x56] 'V'    [ 57]
,  { 87,  7, 0x0000'0072}           // [0x57] 'W'    [ 58]
,  { 89,  7, 0x0000'0073}           // [0x59] 'Y'    [ 59]
,  {106,  7, 0x0000'0074}           // [0x6A] 'j'    [ 60]
,  {107,  7, 0x0000'0075}           // [0x6B] 'k'    [ 61]
,  {113,  7, 0x0000'0076}           // [0x71] 'q'    [ 62]
,  {118,  7, 0x0000'0077}           // [0x76] 'v'    [ 63]
,  {119,  7, 0x0000'0078}           // [0x77] 'w'    [ 64]
,  {120,  7, 0x0000'0079}           // [0x78] 'x'    [ 65]
,  {121,  7, 0x0000'007A}           // [0x79] 'y'    [ 66]
,  {122,  7, 0x0000'007B}           // [0x7A] 'z'    [ 67] 1111010
,  { 38,  8, 0x0000'00F8}           // [0x26] '&'    [ 68] 11111000
,  { 42,  8, 0x0000'00F9}           // [0x2A] '*'    [ 69]
,  { 44,  8, 0x0000'00FA}           // [0x2C] ','    [ 70]
,  { 59,  8, 0x0000'00FB}           // [0x3B] ';'    [ 71]
,  { 88,  8, 0x0000'00FC}           // [0x58] 'X'    [ 72]
,  { 90,  8, 0x0000'00FD}           // [0x5A] 'Z'    [ 73] 11111100
,  { 33, 10, 0x0000'03F8}           // [0x21] '!'    [ 74] F111000
,  { 34, 10, 0x0000'03F9}           // [0x22] '"'    [ 75]
,  { 40, 10, 0x0000'03FA}           // [0x28] '('    [ 76]
,  { 41, 10, 0x0000'03FB}           // [0x29] ')'    [ 77]
,  { 63, 10, 0x0000'03FC}           // [0x3F] '?'    [ 78] F111100
,  { 39, 11, 0x0000'07FA}           // [0x27] '\''   [ 79] F1111010
,  { 43, 11, 0x0000'07FB}           // [0x2B] '+'    [ 80]
,  {124, 11, 0x0000'07FC}           // [0x7C] '|'    [ 81] F1111100
,  { 35, 12, 0x0000'0FFA}           // [0x23] '#'    [ 82] FF1010
,  { 62, 12, 0x0000'0FFB}           // [0x3E] '>'    [ 83] FF1011
,  {  0, 13, 0x0000'1FF8}           // [0x00] '\0'   [ 84] FF11000 NUL
,  { 36, 13, 0x0000'1FF9}           // [0x24] '$'    [ 85]
,  { 64, 13, 0x0000'1FFA}           // [0x40] '@'    [ 86]
,  { 91, 13, 0x0000'1FFB}           // [0x5B] '['    [ 87]
,  { 93, 13, 0x0000'1FFC}           // [0x5D] ']'    [ 88]
,  {126, 13, 0x0000'1FFD}           // [0x7E] '~'    [ 89] FF11011
,  { 94, 14, 0x0000'3FFC}           // [0x5E] '^'    [ 90] FF111100
,  {125, 14, 0x0000'3FFD}           // [0x7D] '}'    [ 91] FF111101
,  { 60, 15, 0x0000'7FFC}           // [0x3C] '<'    [ 92] FF1111100
,  { 96, 15, 0x0000'7FFD}           // [0x60] '`'    [ 93]
,  {123, 15, 0x0000'7FFE}           // [0x7B] '{'    [ 94] FF1111110
,  { 92, 19, 0x0007'FFF0}           // [0x5C] '\\'   [ 95] FFF1110000
,  {195, 19, 0x0007'FFF1}           // [0xC3]        [ 96]
,  {208, 19, 0x0007'FFF2}           // [0xD0]        [ 97] FFF1110010
,  {128, 20, 0x000F'FFE6}           // [0x80]        [ 98] FFF11100110
,  {130, 20, 0x000F'FFE7}           // [0x82]        [ 99]
,  {131, 20, 0x000F'FFE8}           // [0x83]        [100]
,  {162, 20, 0x000F'FFE9}           // [0xA2]        [101]
,  {184, 20, 0x000F'FFEA}           // [0xB8]        [102]
,  {194, 20, 0x000F'FFEB}           // [0xC2]        [103]
,  {224, 20, 0x000F'FFEC}           // [0xE0]        [104]
,  {226, 20, 0x000F'FFED}           // [0xE2]        [105] FFF11101101
,  {153, 21, 0x001F'FFDC}           // [0x99]        [106] FFF111011100
,  {161, 21, 0x001F'FFDD}           // [0xA1]        [107]
,  {167, 21, 0x001F'FFDE}           // [0xA7]        [108]
,  {172, 21, 0x001F'FFDF}           // [0xAC]        [109]
,  {176, 21, 0x001F'FFE0}           // [0xB0]        [110]
,  {177, 21, 0x001F'FFE1}           // [0xB1]        [111]
,  {179, 21, 0x001F'FFE2}           // [0xB3]        [112]
,  {209, 21, 0x001F'FFE3}           // [0xD1]        [113]
,  {216, 21, 0x001F'FFE4}           // [0xD8]        [114]
,  {217, 21, 0x001F'FFE5}           // [0xD9]        [115]
,  {227, 21, 0x001F'FFE6}           // [0xE3]        [116]
,  {229, 21, 0x001F'FFE7}           // [0xE5]        [117]
,  {230, 21, 0x001F'FFE8}           // [0xE6]        [118] FFF111100111
,  {129, 22, 0x003F'FFD2}           // [0x81]        [119] FFF1111100100
,  {132, 22, 0x003F'FFD3}           // [0x84]        [120]
,  {133, 22, 0x003F'FFD4}           // [0x85]        [121]
,  {134, 22, 0x003F'FFD5}           // [0x86]        [122]
,  {136, 22, 0x003F'FFD6}           // [0x88]        [123]
,  {146, 22, 0x003F'FFD7}           // [0x92]        [124]
,  {154, 22, 0x003F'FFD8}           // [0x9A]        [125]
,  {156, 22, 0x003F'FFD9}           // [0x9C]        [126]
,  {160, 22, 0x003F'FFDA}           // [0xA0]        [127]
,  {163, 22, 0x003F'FFDB}           // [0xA3]        [128]
,  {164, 22, 0x003F'FFDC}           // [0xA4]        [129]
,  {169, 22, 0x003F'FFDD}           // [0xA9]        [130]
,  {170, 22, 0x003F'FFDE}           // [0xAA]        [131]
,  {173, 22, 0x003F'FFDF}           // [0xAD]        [132]
,  {178, 22, 0x003F'FFE0}           // [0xB2]        [133]
,  {181, 22, 0x003F'FFE1}           // [0xB5]        [134]
,  {185, 22, 0x003F'FFE2}           // [0xB9]        [135]
,  {186, 22, 0x003F'FFE3}           // [0xBA]        [136]
,  {187, 22, 0x003F'FFE4}           // [0xBB]        [137]
,  {189, 22, 0x003F'FFE5}           // [0xBD]        [138]
,  {190, 22, 0x003F'FFE6}           // [0xBE]        [139]
,  {196, 22, 0x003F'FFE7}           // [0xC4]        [140]
,  {198, 22, 0x003F'FFE8}           // [0xC6]        [141]
,  {228, 22, 0x003F'FFE9}           // [0xE4]        [142]
,  {232, 22, 0x003F'FFEA}           // [0xE8]        [143]
,  {233, 22, 0x003F'FFEB}           // [0xE9]        [144] FFF1111101011
,  {  1, 23, 0x007F'FFD8}           // [0x01]        [145] FFF11111011000
,  {135, 23, 0x007F'FFD9}           // [0x87]        [146]
,  {137, 23, 0x007F'FFDA}           // [0x89]        [147]
,  {138, 23, 0x007F'FFDB}           // [0x8A]        [148]
,  {139, 23, 0x007F'FFDC}           // [0x8B]        [149]
,  {140, 23, 0x007F'FFDD}           // [0x8C]        [150]
,  {141, 23, 0x007F'FFDE}           // [0x8D]        [151]
,  {143, 23, 0x007F'FFDF}           // [0x8F]        [152]
,  {147, 23, 0x007F'FFE0}           // [0x93]        [153]
,  {149, 23, 0x007F'FFE1}           // [0x95]        [154]
,  {150, 23, 0x007F'FFE2}           // [0x96]        [155]
,  {151, 23, 0x007F'FFE3}           // [0x97]        [156]
,  {152, 23, 0x007F'FFE4}           // [0x98]        [157]
,  {155, 23, 0x007F'FFE5}           // [0x9B]        [158]
,  {157, 23, 0x007F'FFE6}           // [0x9D]        [159]
,  {158, 23, 0x007F'FFE7}           // [0x9E]        [160]
,  {165, 23, 0x007F'FFE8}           // [0xA5]        [161]
,  {166, 23, 0x007F'FFE9}           // [0xA6]        [162]
,  {168, 23, 0x007F'FFEA}           // [0xA8]        [163]
,  {174, 23, 0x007F'FFEB}           // [0xAE]        [164]
,  {175, 23, 0x007F'FFEC}           // [0xAF]        [165]
,  {180, 23, 0x007F'FFED}           // [0xB4]        [166]
,  {182, 23, 0x007F'FFEE}           // [0xB6]        [167]
,  {183, 23, 0x007F'FFEF}           // [0xB7]        [168]
,  {188, 23, 0x007F'FFF0}           // [0xBC]        [169]
,  {191, 23, 0x007F'FFF1}           // [0xBF]        [170]
,  {197, 23, 0x007F'FFF2}           // [0xC5]        [171]
,  {231, 23, 0x007F'FFF3}           // [0xE7]        [172]
,  {239, 23, 0x007F'FFF4}           // [0xEF]        [173] FFF11111110100
,  {  9, 24, 0x00FF'FFEA}           // [0x09] '\t'   [174] FFFF11101010 Tab
,  {142, 24, 0x00FF'FFEB}           // [0x8E]        [175]
,  {144, 24, 0x00FF'FFEC}           // [0x90]        [176]
,  {145, 24, 0x00FF'FFED}           // [0x91]        [177]
,  {148, 24, 0x00FF'FFEE}           // [0x94]        [178]
,  {159, 24, 0x00FF'FFEF}           // [0x9F]        [179]
,  {171, 24, 0x00FF'FFF0}           // [0xAB]        [180]
,  {206, 24, 0x00FF'FFF1}           // [0xCE]        [181]
,  {215, 24, 0x00FF'FFF2}           // [0xD7]        [182]
,  {225, 24, 0x00FF'FFF3}           // [0xE1]        [183]
,  {236, 24, 0x00FF'FFF4}           // [0xEC]        [184]
,  {237, 24, 0x00FF'FFF5}           // [0xED]        [185] FFFF11110101
,  {199, 25, 0x01FF'FFEC}           // [0xC7]        [186] FFFF111101100
,  {207, 25, 0x01FF'FFED}           // [0xCF]        [187]
,  {234, 25, 0x01FF'FFEE}           // [0xEA]        [188]
,  {235, 25, 0x01FF'FFEF}           // [0xEB]        [189] FFFF111101111
,  {192, 26, 0x03FF'FFE0}           // [0xC0]        [190] FFFF1111100000
,  {193, 26, 0x03FF'FFE1}           // [0xC1]        [191]
,  {200, 26, 0x03FF'FFE2}           // [0xC8]        [192]
,  {201, 26, 0x03FF'FFE3}           // [0xC9]        [193]
,  {202, 26, 0x03FF'FFE4}           // [0xCA]        [194]
,  {205, 26, 0x03FF'FFE5}           // [0xCD]        [195]
,  {210, 26, 0x03FF'FFE6}           // [0xD2]        [196]
,  {213, 26, 0x03FF'FFE7}           // [0xD5]        [197]
,  {218, 26, 0x03FF'FFE8}           // [0xDA]        [198]
,  {219, 26, 0x03FF'FFE9}           // [0xDB]        [199]
,  {238, 26, 0x03FF'FFEA}           // [0xEE]        [200]
,  {240, 26, 0x03FF'FFEB}           // [0xF0]        [201]
,  {242, 26, 0x03FF'FFEC}           // [0xF2]        [202]
,  {243, 26, 0x03FF'FFED}           // [0xF3]        [203]
,  {255, 26, 0x03FF'FFEE}           // [0xFF]        [204] FFFF1111101110
,  {203, 27, 0x07FF'FFDE}           // [0xCB]        [205] FFFF11111011110
,  {204, 27, 0x07FF'FFDF}           // [0xCC]        [206]
,  {211, 27, 0x07FF'FFE0}           // [0xD3]        [207]
,  {212, 27, 0x07FF'FFE1}           // [0xD4]        [208]
,  {214, 27, 0x07FF'FFE2}           // [0xD6]        [209]
,  {221, 27, 0x07FF'FFE3}           // [0xDD]        [210]
,  {222, 27, 0x07FF'FFE4}           // [0xDE]        [211]
,  {223, 27, 0x07FF'FFE5}           // [0xDF]        [212]
,  {241, 27, 0x07FF'FFE6}           // [0xF1]        [213]
,  {244, 27, 0x07FF'FFE7}           // [0xF4]        [214]
,  {245, 27, 0x07FF'FFE8}           // [0xF5]        [215]
,  {246, 27, 0x07FF'FFE9}           // [0xF6]        [216]
,  {247, 27, 0x07FF'FFEA}           // [0xF7]        [217]
,  {248, 27, 0x07FF'FFEB}           // [0xF8]        [218]
,  {250, 27, 0x07FF'FFEC}           // [0xFA]        [219]
,  {251, 27, 0x07FF'FFED}           // [0xFB]        [220]
,  {252, 27, 0x07FF'FFEE}           // [0xFC]        [221]
,  {253, 27, 0x07FF'FFEF}           // [0xFD]        [222]
,  {254, 27, 0x07FF'FFF0}           // [0xFE]        [223] FFFF11111110000
,  {  2, 28, 0x0FFF'FFE2}           // [0x02]        [224] FFFFF11100010
,  {  3, 28, 0x0FFF'FFE3}           // [0x03]        [225]
,  {  4, 28, 0x0FFF'FFE4}           // [0x04]        [226]
,  {  5, 28, 0x0FFF'FFE5}           // [0x05]        [227]
,  {  6, 28, 0x0FFF'FFE6}           // [0x06]        [228]
,  {  7, 28, 0x0FFF'FFE7}           // [0x07]        [229]
,  {  8, 28, 0x0FFF'FFE8}           // [0x08] '\b'   [230] Backspace
,  { 11, 28, 0x0FFF'FFE9}           // [0x0B]        [231]
,  { 12, 28, 0x0FFF'FFEA}           // [0x0C]        [232]
,  { 14, 28, 0x0FFF'FFEB}           // [0x0E]        [233]
,  { 15, 28, 0x0FFF'FFEC}           // [0x0F]        [234]
,  { 16, 28, 0x0FFF'FFED}           // [0x10]        [235]
,  { 17, 28, 0x0FFF'FFEE}           // [0x11]        [236]
,  { 18, 28, 0x0FFF'FFEF}           // [0x12]        [237]
,  { 19, 28, 0x0FFF'FFF0}           // [0x13]        [238]
,  { 20, 28, 0x0FFF'FFF1}           // [0x14]        [239]
,  { 21, 28, 0x0FFF'FFF2}           // [0x15]        [240]
,  { 23, 28, 0x0FFF'FFF3}           // [0x17]        [241]
,  { 24, 28, 0x0FFF'FFF4}           // [0x18]        [242]
,  { 25, 28, 0x0FFF'FFF5}           // [0x19]        [243]
,  { 26, 28, 0x0FFF'FFF6}           // [0x1A]        [244]
,  { 27, 28, 0x0FFF'FFF7}           // [0x1B]        [245]
,  { 28, 28, 0x0FFF'FFF8}           // [0x1C]        [246]
,  { 29, 28, 0x0FFF'FFF9}           // [0x1D]        [247]
,  { 30, 28, 0x0FFF'FFFA}           // [0x1E]        [248]
,  { 31, 28, 0x0FFF'FFFB}           // [0x1F]        [249]
,  {127, 28, 0x0FFF'FFFC}           // [0x7F] (DEL)  [250]
,  {220, 28, 0x0FFF'FFFD}           // [0xDC]        [251]
,  {249, 28, 0x0FFF'FFFE}           // [0xF9]        [252] FFFFF11111110
,  { 10, 30, 0x3FFF'FFFC}           // [0x0A] '\n'   [253] Line Feed
//                                                         FFFFFF111100
,  { 13, 30, 0x3FFF'FFFD}           // [0x0D] '\r'   [254] Carriage return
,  { 22, 30, 0x3FFF'FFFE}           // [0x16]  (SYN) [255] Synchronize
//                                                         FFFFFF111110
}; // Huff7541 decode_table

//----------------------------------------------------------------------------
//
// Data area-
//       encode_table
//
// Purpose-
//       RFC7541 Huffman encoding table
//
//----------------------------------------------------------------------------
static const Huff7541   encode_table[ENCODE_TABLE_DIM]=
{  {  0, 13, 0x0000'1FF8}           // [0x00] '\0' NUL
,  {  1, 23, 0x007F'FFD8}           // [0x01]
,  {  2, 28, 0x0FFF'FFE2}           // [0x02]
,  {  3, 28, 0x0FFF'FFE3}           // [0x03]
,  {  4, 28, 0x0FFF'FFE4}           // [0x04]
,  {  5, 28, 0x0FFF'FFE5}           // [0x05]
,  {  6, 28, 0x0FFF'FFE6}           // [0x06]
,  {  7, 28, 0x0FFF'FFE7}           // [0x07]
,  {  8, 28, 0x0FFF'FFE8}           // [0x08] '\b' Backspace
,  {  9, 24, 0x00FF'FFEA}           // [0x09] '\t' Tab
,  { 10, 30, 0x3FFF'FFFC}           // [0x0A] '\n' Line Feed
,  { 11, 28, 0x0FFF'FFE9}           // [0x0B]
,  { 12, 28, 0x0FFF'FFEA}           // [0x0C]
,  { 13, 30, 0x3FFF'FFFD}           // [0x0D] '\r' Carriage return
,  { 14, 28, 0x0FFF'FFEB}           // [0x0E]
,  { 15, 28, 0x0FFF'FFEC}           // [0x0F]
,  { 16, 28, 0x0FFF'FFED}           // [0x10]
,  { 17, 28, 0x0FFF'FFEE}           // [0x11]
,  { 18, 28, 0x0FFF'FFEF}           // [0x12]
,  { 19, 28, 0x0FFF'FFF0}           // [0x13]
,  { 20, 28, 0x0FFF'FFF1}           // [0x14]
,  { 21, 28, 0x0FFF'FFF2}           // [0x15]
,  { 22, 30, 0x3FFF'FFFE}           // [0x16] (SYN) Synchronize
,  { 23, 28, 0x0FFF'FFF3}           // [0x17]
,  { 24, 28, 0x0FFF'FFF4}           // [0x18]
,  { 25, 28, 0x0FFF'FFF5}           // [0x19]
,  { 26, 28, 0x0FFF'FFF6}           // [0x1A]
,  { 27, 28, 0x0FFF'FFF7}           // [0x1B]
,  { 28, 28, 0x0FFF'FFF8}           // [0x1C]
,  { 29, 28, 0x0FFF'FFF9}           // [0x1D]
,  { 30, 28, 0x0FFF'FFFA}           // [0x1E]
,  { 31, 28, 0x0FFF'FFFB}           // [0x1F]
,  { 32,  6, 0x0000'0014}           // [0x20] ' '
,  { 33, 10, 0x0000'03F8}           // [0x21] '!'
,  { 34, 10, 0x0000'03F9}           // [0x22] '"'
,  { 35, 12, 0x0000'0FFA}           // [0x23] '#'
,  { 36, 13, 0x0000'1FF9}           // [0x24] '$'
,  { 37,  6, 0x0000'0015}           // [0x25] '%'
,  { 38,  8, 0x0000'00F8}           // [0x26] '&'
,  { 39, 11, 0x0000'07FA}           // [0x27] '\''
,  { 40, 10, 0x0000'03FA}           // [0x28] '('
,  { 41, 10, 0x0000'03FB}           // [0x29] ')'
,  { 42,  8, 0x0000'00F9}           // [0x2A] '*'
,  { 43, 11, 0x0000'07FB}           // [0x2B] '+'
,  { 44,  8, 0x0000'00FA}           // [0x2C] ','
,  { 45,  6, 0x0000'0016}           // [0x2D] '-'
,  { 46,  6, 0x0000'0017}           // [0x2E] '.'
,  { 47,  6, 0x0000'0018}           // [0x2F] '/'
,  { 48,  5, 0x0000'0000}           // [0x30] '0'
,  { 49,  5, 0x0000'0001}           // [0x31] '1'
,  { 50,  5, 0x0000'0002}           // [0x32] '2'
,  { 51,  6, 0x0000'0019}           // [0x33] '3'
,  { 52,  6, 0x0000'001A}           // [0x34] '4'
,  { 53,  6, 0x0000'001B}           // [0x35] '5'
,  { 54,  6, 0x0000'001C}           // [0x36] '6'
,  { 55,  6, 0x0000'001D}           // [0x37] '7'
,  { 56,  6, 0x0000'001E}           // [0x38] '8'
,  { 57,  6, 0x0000'001F}           // [0x39] '9'
,  { 58,  7, 0x0000'005C}           // [0x3A] ':'
,  { 59,  8, 0x0000'00FB}           // [0x3B] ';'
,  { 60, 15, 0x0000'7FFC}           // [0x3C] '<'
,  { 61,  6, 0x0000'0020}           // [0x3D] '='
,  { 62, 12, 0x0000'0FFB}           // [0x3E] '>'
,  { 63, 10, 0x0000'03FC}           // [0x3F] '?'
,  { 64, 13, 0x0000'1FFA}           // [0x40] '@'
,  { 65,  6, 0x0000'0021}           // [0x41] 'A'
,  { 66,  7, 0x0000'005D}           // [0x42] 'B'
,  { 67,  7, 0x0000'005E}           // [0x43] 'C'
,  { 68,  7, 0x0000'005F}           // [0x44] 'D'
,  { 69,  7, 0x0000'0060}           // [0x45] 'E'
,  { 70,  7, 0x0000'0061}           // [0x46] 'F'
,  { 71,  7, 0x0000'0062}           // [0x47] 'G'
,  { 72,  7, 0x0000'0063}           // [0x48] 'H'
,  { 73,  7, 0x0000'0064}           // [0x49] 'I'
,  { 74,  7, 0x0000'0065}           // [0x4A] 'J'
,  { 75,  7, 0x0000'0066}           // [0x4B] 'K'
,  { 76,  7, 0x0000'0067}           // [0x4C] 'L'
,  { 77,  7, 0x0000'0068}           // [0x4D] 'M'
,  { 78,  7, 0x0000'0069}           // [0x4E] 'N'
,  { 79,  7, 0x0000'006A}           // [0x4F] 'O'
,  { 80,  7, 0x0000'006B}           // [0x50] 'P'
,  { 81,  7, 0x0000'006C}           // [0x51] 'Q'
,  { 82,  7, 0x0000'006D}           // [0x52] 'R'
,  { 83,  7, 0x0000'006E}           // [0x53] 'S'
,  { 84,  7, 0x0000'006F}           // [0x54] 'T'
,  { 85,  7, 0x0000'0070}           // [0x55] 'U'
,  { 86,  7, 0x0000'0071}           // [0x56] 'V'
,  { 87,  7, 0x0000'0072}           // [0x57] 'W'
,  { 88,  8, 0x0000'00FC}           // [0x58] 'X'
,  { 89,  7, 0x0000'0073}           // [0x59] 'Y'
,  { 90,  8, 0x0000'00FD}           // [0x5A] 'Z'
,  { 91, 13, 0x0000'1FFB}           // [0x5B] '['
,  { 92, 19, 0x0007'FFF0}           // [0x5C] '\\'
,  { 93, 13, 0x0000'1FFC}           // [0x5D] ']'
,  { 94, 14, 0x0000'3FFC}           // [0x5E] '^'
,  { 95,  6, 0x0000'0022}           // [0x5F] '_'
,  { 96, 15, 0x0000'7FFD}           // [0x60] '`'
,  { 97,  5, 0x0000'0003}           // [0x61] 'a'
,  { 98,  6, 0x0000'0023}           // [0x62] 'b'
,  { 99,  5, 0x0000'0004}           // [0x63] 'c'
,  {100,  6, 0x0000'0024}           // [0x64] 'd'
,  {101,  5, 0x0000'0005}           // [0x65] 'e'
,  {102,  6, 0x0000'0025}           // [0x66] 'f'
,  {103,  6, 0x0000'0026}           // [0x67] 'g'
,  {104,  6, 0x0000'0027}           // [0x68] 'h'
,  {105,  5, 0x0000'0006}           // [0x69] 'i'
,  {106,  7, 0x0000'0074}           // [0x6A] 'j'
,  {107,  7, 0x0000'0075}           // [0x6B] 'k'
,  {108,  6, 0x0000'0028}           // [0x6C] 'l'
,  {109,  6, 0x0000'0029}           // [0x6D] 'm'
,  {110,  6, 0x0000'002A}           // [0x6E] 'n'
,  {111,  5, 0x0000'0007}           // [0x6F] 'o'
,  {112,  6, 0x0000'002B}           // [0x70] 'p'
,  {113,  7, 0x0000'0076}           // [0x71] 'q'
,  {114,  6, 0x0000'002C}           // [0x72] 'r'
,  {115,  5, 0x0000'0008}           // [0x73] 's'
,  {116,  5, 0x0000'0009}           // [0x74] 't'
,  {117,  6, 0x0000'002D}           // [0x75] 'u'
,  {118,  7, 0x0000'0077}           // [0x76] 'v'
,  {119,  7, 0x0000'0078}           // [0x77] 'w'
,  {120,  7, 0x0000'0079}           // [0x78] 'x'
,  {121,  7, 0x0000'007A}           // [0x79] 'y'
,  {122,  7, 0x0000'007B}           // [0x7A] 'z'
,  {123, 15, 0x0000'7FFE}           // [0x7B] '{'
,  {124, 11, 0x0000'07FC}           // [0x7C] '|'
,  {125, 14, 0x0000'3FFD}           // [0x7D] '}'
,  {126, 13, 0x0000'1FFD}           // [0x7E] '~'
,  {127, 28, 0x0FFF'FFFC}           // [0x7F] (DEL)
,  {128, 20, 0x000F'FFE6}           // [0x80]
,  {129, 22, 0x003F'FFD2}           // [0x81]
,  {130, 20, 0x000F'FFE7}           // [0x82]
,  {131, 20, 0x000F'FFE8}           // [0x83]
,  {132, 22, 0x003F'FFD3}           // [0x84]
,  {133, 22, 0x003F'FFD4}           // [0x85]
,  {134, 22, 0x003F'FFD5}           // [0x86]
,  {135, 23, 0x007F'FFD9}           // [0x87]
,  {136, 22, 0x003F'FFD6}           // [0x88]
,  {137, 23, 0x007F'FFDA}           // [0x89]
,  {138, 23, 0x007F'FFDB}           // [0x8A]
,  {139, 23, 0x007F'FFDC}           // [0x8B]
,  {140, 23, 0x007F'FFDD}           // [0x8C]
,  {141, 23, 0x007F'FFDE}           // [0x8D]
,  {142, 24, 0x00FF'FFEB}           // [0x8E]
,  {143, 23, 0x007F'FFDF}           // [0x8F]
,  {144, 24, 0x00FF'FFEC}           // [0x90]
,  {145, 24, 0x00FF'FFED}           // [0x91]
,  {146, 22, 0x003F'FFD7}           // [0x92]
,  {147, 23, 0x007F'FFE0}           // [0x93]
,  {148, 24, 0x00FF'FFEE}           // [0x94]
,  {149, 23, 0x007F'FFE1}           // [0x95]
,  {150, 23, 0x007F'FFE2}           // [0x96]
,  {151, 23, 0x007F'FFE3}           // [0x97]
,  {152, 23, 0x007F'FFE4}           // [0x98]
,  {153, 21, 0x001F'FFDC}           // [0x99]
,  {154, 22, 0x003F'FFD8}           // [0x9A]
,  {155, 23, 0x007F'FFE5}           // [0x9B]
,  {156, 22, 0x003F'FFD9}           // [0x9C]
,  {157, 23, 0x007F'FFE6}           // [0x9D]
,  {158, 23, 0x007F'FFE7}           // [0x9E]
,  {159, 24, 0x00FF'FFEF}           // [0x9F]
,  {160, 22, 0x003F'FFDA}           // [0xA0]
,  {161, 21, 0x001F'FFDD}           // [0xA1]
,  {162, 20, 0x000F'FFE9}           // [0xA2]
,  {163, 22, 0x003F'FFDB}           // [0xA3]
,  {164, 22, 0x003F'FFDC}           // [0xA4]
,  {165, 23, 0x007F'FFE8}           // [0xA5]
,  {166, 23, 0x007F'FFE9}           // [0xA6]
,  {167, 21, 0x001F'FFDE}           // [0xA7]
,  {168, 23, 0x007F'FFEA}           // [0xA8]
,  {169, 22, 0x003F'FFDD}           // [0xA9]
,  {170, 22, 0x003F'FFDE}           // [0xAA]
,  {171, 24, 0x00FF'FFF0}           // [0xAB]
,  {172, 21, 0x001F'FFDF}           // [0xAC]
,  {173, 22, 0x003F'FFDF}           // [0xAD]
,  {174, 23, 0x007F'FFEB}           // [0xAE]
,  {175, 23, 0x007F'FFEC}           // [0xAF]
,  {176, 21, 0x001F'FFE0}           // [0xB0]
,  {177, 21, 0x001F'FFE1}           // [0xB1]
,  {178, 22, 0x003F'FFE0}           // [0xB2]
,  {179, 21, 0x001F'FFE2}           // [0xB3]
,  {180, 23, 0x007F'FFED}           // [0xB4]
,  {181, 22, 0x003F'FFE1}           // [0xB5]
,  {182, 23, 0x007F'FFEE}           // [0xB6]
,  {183, 23, 0x007F'FFEF}           // [0xB7]
,  {184, 20, 0x000F'FFEA}           // [0xB8]
,  {185, 22, 0x003F'FFE2}           // [0xB9]
,  {186, 22, 0x003F'FFE3}           // [0xBA]
,  {187, 22, 0x003F'FFE4}           // [0xBB]
,  {188, 23, 0x007F'FFF0}           // [0xBC]
,  {189, 22, 0x003F'FFE5}           // [0xBD]
,  {190, 22, 0x003F'FFE6}           // [0xBE]
,  {191, 23, 0x007F'FFF1}           // [0xBF]
,  {192, 26, 0x03FF'FFE0}           // [0xC0]
,  {193, 26, 0x03FF'FFE1}           // [0xC1]
,  {194, 20, 0x000F'FFEB}           // [0xC2]
,  {195, 19, 0x0007'FFF1}           // [0xC3]
,  {196, 22, 0x003F'FFE7}           // [0xC4]
,  {197, 23, 0x007F'FFF2}           // [0xC5]
,  {198, 22, 0x003F'FFE8}           // [0xC6]
,  {199, 25, 0x01FF'FFEC}           // [0xC7]
,  {200, 26, 0x03FF'FFE2}           // [0xC8]
,  {201, 26, 0x03FF'FFE3}           // [0xC9]
,  {202, 26, 0x03FF'FFE4}           // [0xCA]
,  {203, 27, 0x07FF'FFDE}           // [0xCB]
,  {204, 27, 0x07FF'FFDF}           // [0xCC]
,  {205, 26, 0x03FF'FFE5}           // [0xCD]
,  {206, 24, 0x00FF'FFF1}           // [0xCE]
,  {207, 25, 0x01FF'FFED}           // [0xCF]
,  {208, 19, 0x0007'FFF2}           // [0xD0]
,  {209, 21, 0x001F'FFE3}           // [0xD1]
,  {210, 26, 0x03FF'FFE6}           // [0xD2]
,  {211, 27, 0x07FF'FFE0}           // [0xD3]
,  {212, 27, 0x07FF'FFE1}           // [0xD4]
,  {213, 26, 0x03FF'FFE7}           // [0xD5]
,  {214, 27, 0x07FF'FFE2}           // [0xD6]
,  {215, 24, 0x00FF'FFF2}           // [0xD7]
,  {216, 21, 0x001F'FFE4}           // [0xD8]
,  {217, 21, 0x001F'FFE5}           // [0xD9]
,  {218, 26, 0x03FF'FFE8}           // [0xDA]
,  {219, 26, 0x03FF'FFE9}           // [0xDB]
,  {220, 28, 0x0FFF'FFFD}           // [0xDC]
,  {221, 27, 0x07FF'FFE3}           // [0xDD]
,  {222, 27, 0x07FF'FFE4}           // [0xDE]
,  {223, 27, 0x07FF'FFE5}           // [0xDF]
,  {224, 20, 0x000F'FFEC}           // [0xE0]
,  {225, 24, 0x00FF'FFF3}           // [0xE1]
,  {226, 20, 0x000F'FFED}           // [0xE2]
,  {227, 21, 0x001F'FFE6}           // [0xE3]
,  {228, 22, 0x003F'FFE9}           // [0xE4]
,  {229, 21, 0x001F'FFE7}           // [0xE5]
,  {230, 21, 0x001F'FFE8}           // [0xE6]
,  {231, 23, 0x007F'FFF3}           // [0xE7]
,  {232, 22, 0x003F'FFEA}           // [0xE8]
,  {233, 22, 0x003F'FFEB}           // [0xE9]
,  {234, 25, 0x01FF'FFEE}           // [0xEA]
,  {235, 25, 0x01FF'FFEF}           // [0xEB]
,  {236, 24, 0x00FF'FFF4}           // [0xEC]
,  {237, 24, 0x00FF'FFF5}           // [0xED]
,  {238, 26, 0x03FF'FFEA}           // [0xEE]
,  {239, 23, 0x007F'FFF4}           // [0xEF]
,  {240, 26, 0x03FF'FFEB}           // [0xF0]
,  {241, 27, 0x07FF'FFE6}           // [0xF1]
,  {242, 26, 0x03FF'FFEC}           // [0xF2]
,  {243, 26, 0x03FF'FFED}           // [0xF3]
,  {244, 27, 0x07FF'FFE7}           // [0xF4]
,  {245, 27, 0x07FF'FFE8}           // [0xF5]
,  {246, 27, 0x07FF'FFE9}           // [0xF6]
,  {247, 27, 0x07FF'FFEA}           // [0xF7]
,  {248, 27, 0x07FF'FFEB}           // [0xF8]
,  {249, 28, 0x0FFF'FFFE}           // [0xF9]
,  {250, 27, 0x07FF'FFEC}           // [0xFA]
,  {251, 27, 0x07FF'FFED}           // [0xFB]
,  {252, 27, 0x07FF'FFEE}           // [0xFC]
,  {253, 27, 0x07FF'FFEF}           // [0xFD]
,  {254, 27, 0x07FF'FFF0}           // [0xFE]
,  {255, 26, 0x03FF'FFEE}           // [0xFF]
}; // Huff7541 encode_table

//----------------------------------------------------------------------------
// End Of String (Must not actually appear in an encoded string)
//----------------------------------------------------------------------------
Huff7541               EOS= {256, 30, 0x3FFF'FFFF}; // End Of String

//----------------------------------------------------------------------------
//
// Data area-
//       static_entry
//
// Purpose-
//       RFC7541 static entry table
//
//----------------------------------------------------------------------------
#define GEN7541(name, value, index, encoding) \
        Entry_const(name, value, index)

// Specification notes:
//   Entry[16] value("gzip, deflate") The space is not a typo.
//   Entry[19] index("accept") is not alphabetized.
Entry_const            static_entry[STATIC_ENTRY_DIM]=
{  GEN7541(nullptr,            nullptr,  0, 0x00) // [ 0] (Not used)
,  GEN7541(":authority",       nullptr,  1, 0x10) // [ 1]
,  GEN7541(":method",          "GET",    2, 0x80) // [ 2]
,  GEN7541(":method",          "POST",   3, 0x80) // [ 3]
,  GEN7541(":path",            "/",      4, 0x80) // [ 4]
,  GEN7541(":path",            "/index.html"      // [ 5]
,                                        5, 0x80)
,  GEN7541(":scheme",          "http",   6, 0x80) // [ 6]
,  GEN7541(":scheme",          "https",  7, 0x80) // [ 7]
,  GEN7541(":status",          "200",    8, 0x80) // [ 8]
,  GEN7541(":status",          "204",    9, 0x80) // [ 9]
,  GEN7541(":status",          "206",   10, 0x80) // [10]
,  GEN7541(":status",          "304",   11, 0x80) // [11]
,  GEN7541(":status",          "400",   12, 0x80) // [12]
,  GEN7541(":status",          "404",   13, 0x80) // [13]
,  GEN7541(":status",          "500",   14, 0x80) // [14]
,  GEN7541("accept-charset",   nullptr, 15, 0x80) // [15]
,  GEN7541("accept-encoding",  "gzip, deflate"    // [16]
,                                       16, 0x80)
,  GEN7541("accept-language",  nullptr, 17, 0x80) // [17]
,  GEN7541("accept-ranges",    nullptr, 18, 0x80) // [18]
,  GEN7541("accept",           nullptr, 19, 0x80) // [19]
,  GEN7541("access-control-allow-origin"          // [20]
,                              nullptr, 20, 0x80)
,  GEN7541("age",              nullptr, 21, 0x80) // [21]
,  GEN7541("allow",            nullptr, 22, 0x80) // [22]
,  GEN7541("authorization",    nullptr, 23, 0x10) // [23]
,  GEN7541("cache-control",    nullptr, 24, 0x80) // [24]
,  GEN7541("content-disposition"                  // [25]
,                              nullptr, 25, 0x80)
,  GEN7541("content-encoding", nullptr, 26, 0x80) // [26]
,  GEN7541("content-language", nullptr, 27, 0x80) // [27]
,  GEN7541("content-length",   nullptr, 28, 0x80) // [28]
,  GEN7541("content-location", nullptr, 29, 0x80) // [29]
,  GEN7541("content-range",    nullptr, 30, 0x80) // [30]
,  GEN7541("content-type",     nullptr, 31, 0x80) // [31]
,  GEN7541("cookie",           nullptr, 32, 0x10) // [32]
,  GEN7541("date",             nullptr, 33, 0x80) // [33]
,  GEN7541("etag",             nullptr, 34, 0x80) // [34]
,  GEN7541("expect",           nullptr, 35, 0x80) // [35]
,  GEN7541("expires",          nullptr, 36, 0x80) // [36]
,  GEN7541("from",             nullptr, 37, 0x80) // [37]
,  GEN7541("host",             nullptr, 38, 0x80) // [38]
,  GEN7541("if-match",         nullptr, 39, 0x80) // [39]
,  GEN7541("if-modified-since"                    // [40]
,                              nullptr, 40, 0x80)
,  GEN7541("if-none-match",    nullptr, 41, 0x80) // [41]
,  GEN7541("if-range",         nullptr, 42, 0x80) // [42]
,  GEN7541("if-unmodified-since"                  // [43]
,                              nullptr, 43, 0x80)
,  GEN7541("last-modified",    nullptr, 44, 0x80) // [44]
,  GEN7541("link",             nullptr, 45, 0x80) // [45]
,  GEN7541("location",         nullptr, 46, 0x80) // [46]
,  GEN7541("max-forwards",     nullptr, 47, 0x80) // [47]
,  GEN7541("proxy-authenticate"                   // [48]
,                              nullptr, 48, 0x10)
,  GEN7541("proxy-authorization"                  // [49]
,                              nullptr, 49, 0x10)
,  GEN7541("range",            nullptr, 50, 0x80) // [50]
,  GEN7541("referer",          nullptr, 51, 0x80) // [51]
,  GEN7541("refresh",          nullptr, 52, 0x80) // [52]
,  GEN7541("retry-after",      nullptr, 53, 0x80) // [53]
,  GEN7541("server",           nullptr, 54, 0x80) // [54]
,  GEN7541("set-cookie",       nullptr, 55, 0x10) // [55]
,  GEN7541("strict-transport-security"            // [56]
,                              nullptr, 56, 0x10)
,  GEN7541("transfer-encoding"                    // [57]
,                              nullptr, 57, 0x80)
,  GEN7541("user-agent",       nullptr, 58, 0x80) // [58]
,  GEN7541("vary",             nullptr, 59, 0x80) // [59]
,  GEN7541("via",              nullptr, 60, 0x80) // [60]
,  GEN7541("www-authenticate", nullptr, 61, 0x10) // [61]
}; // Entry static_entry array

//----------------------------------------------------------------------------
// Internal data areas
//----------------------------------------------------------------------------
static const char* type_to_name[8]=
         { "ET_INDEX", "ET_INSERT_NOINDEX", "ET_INSERT", "ET_RESIZE"
         , "ET_NEVER_NOINDEX", "ET_NEVER", "ET_CONST_NOINDEX", "ET_CONST"};

//----------------------------------------------------------------------------
//
// Class-
//       connection_error
//
// Purpose-
//       Connection error exception
//
//----------------------------------------------------------------------------
class connection_error : public std::runtime_error {
using std::runtime_error::runtime_error;
}; // class connection_error

//----------------------------------------------------------------------------
//
// Subroutine-
//       decoder_get
//
// Purpose-
//       Read character from IodaReader, disallowing EOF
//
//----------------------------------------------------------------------------
static int
   decoder_get(IodaReader& ioda)    // Read disallowing EOF
{
   int byte= ioda.get();
   if( byte == EOF )
     throw connection_error("decoder: EOF");
   return byte;
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Entry::Entry
//       RFC7541::Entry::~Entry
//       RFC7541::Entry::debug
//
// Purpose-
//       Constructors
//       Destructor
//       Debugging display
//
//----------------------------------------------------------------------------

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry::Entry(                    // Copy constructor
     const Entry&      I)           // Source Entry
:  pub::List<Entry>::Link()
{
   name=      pub::must::strdup(I.name);
   value=     pub::must::strdup(I.value);
   index=     I.index;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry::Entry(                    // Move constructor
     Entry&&           I)           // Source Entry
:  pub::List<Entry>::Link()
{
   name=      I.name;
   value=     I.value;
   index=     I.index;

   new (&I) Entry();                // Reset source Entry
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry::Entry(                    // Constructor
     const char*       name,        // Name
     const char*       value,       // Value
     Array_ix          index)       // Name index
:  pub::List<Entry>::Link()
,  name(name), value(value), index(index)
{
   if( name )
     this->name= pub::must::strdup(name);
   if( value )
     this->value= pub::must::strdup(value);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry::Entry(                    // Constructor
     const Property&   P)           // Source Property
:  pub::List<Entry>::Link()
,  name(nullptr), value(nullptr), index(0)
{
   name=      pub::must::strdup(P.name.c_str());
   value=     pub::must::strdup(P.value.c_str());
   index=     0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry::~Entry( void )           // Destructor
{  free((void*)name); free((void*)value); }

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void
   Entry::debug(const char* info) const // Debugging display
{  debugf("Entry(%p).debug(%s) [%d] '%s': '%s'\n", this, info
         , index, name, value);
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Entry::operator Property
//
// Purpose-
//       Cast operator
//
//----------------------------------------------------------------------------
   Entry::operator Property( void ) const
{
   Property property(*this);
   return property;
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Entry_const::Entry_const
//
// Purpose-
//       Constructors
//
//----------------------------------------------------------------------------

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry_const::Entry_const(        // Constructor
     const char*       name,        // Name
     const char*       value,       // Value
     Entry_ix          index)       // Name index
:  Entry(name, value, index)
{  }

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Entry_const::Entry_const(        // Copy (const Entry&) constructor
     const Entry&      I)           // Source Entry
:  Entry()
{
   name=      I.name;
   value=     I.value;
   index=     I.index;
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Entry_map::Entry_map
//       RFC7541::Entry_map::~Entry_map

//
// Purpose-
//       Constructor
//       Destructor
//
//----------------------------------------------------------------------------
   Entry_map::Entry_map( void )
{
   // Create the hash table
   size_t size= sizeof(Hash_entry) * HASH_SIZE;
   hash_table= (Hash_entry*)must::malloc(size);
   for(size_t i= 0; i<HASH_SIZE; ++i) {
     Hash_entry& list= hash_table[i];
     new (&list) pub::List<Entry>();
   }

   // Initialize the hash table
   for(size_t i= 1; i<STATIC_ENTRY_DIM; ++i) {
     Entry& ix= static_entry[i];
     Entry_const* entry= new Entry_const(ix);
     insert(entry);
   }
}

   Entry_map::~Entry_map( void )
{
   for(size_t i= 0; i<HASH_SIZE; ++i) {
     Hash_entry& list= hash_table[i]; // The hash list
     for(;;) {                      // Empty the list
       Entry* entry= list.remq();
       if( entry == nullptr )
         break;

       // All dynamic indexes should have been removed by now
       if( entry->is_dynamic() ) {
         debugf("~Entry_map(%p) contained Entry(%p)\n", this, entry);
         entry->debug("?Memory leak?");
       }

       delete entry;
     }
   }

   free(hash_table);
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Entry_map::debug
//
// Purpose-
//       Debugging display
//
//----------------------------------------------------------------------------
void
   Entry_map::debug(const char* info) const // Debugging display
{
   debugf("Entry_map(%p).debug(%s)\n", this, info);
   for(size_t i= 0; i<HASH_SIZE; ++i) {
     Hash_entry& list= hash_table[i]; // The hash list
     // debugf("[%2zd] {%p,%p}\n", i, list.get_head(), list.get_tail());
     for(Entry* entry= list.get_tail(); entry; entry= entry->get_prev()) {
       if( entry->is_dynamic() )
         debugf("..%p[%2d] '%s': '%s'\n", entry, entry->index
               , entry->name, entry->value);
     }
   }
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Entry_map::insert
//       RFC7541::Entry_map::locate
//       RFC7541::Entry_map::remove
//       RFC7541::Entry_map::reset
//
// Purpose-
//       Insert map entry
//       Locate map entry
//       Remove map entry
//       Remove non-const map entries from the map
//
//----------------------------------------------------------------------------
void
   Entry_map::insert(Entry* entry)  // Insert Entry into hash table
{
   std::string S= entry->name;
   size_t ix= std::hash<std::string>{}(S); // Full hash entry
   ix &= HASH_MASK;                 // Table hash entry
   Hash_entry& list= hash_table[ix]; // The hash list
   list.fifo(entry);                // Add Entry to list
}

Entry*
   Entry_map::locate(const char* name, const char* value)
{
   std::string S= name;
   size_t ix= std::hash<std::string>{}(S); // Full hash index
   ix &= HASH_MASK;                 // Table hash index
   Hash_entry& list= hash_table[ix]; // The hash list

   for(Entry* entry= list.get_head(); entry; entry= entry->get_next()) {
     if( strcmp(name, entry->name) == 0 ) { // If name match
       if( value == nullptr )       // If name-only locate
         return entry;
       if( entry->value && strcmp(value, entry->value) == 0 )
         return entry;
     }
   }

   return nullptr;
}

void
   Entry_map::remove(Entry* entry)
{
   std::string S= entry->name;
   size_t ix= std::hash<std::string>{}(S); // Full hash index
   ix &= HASH_MASK;                 // Table hash index
   Hash_entry& list= hash_table[ix]; // The hash list
   if( !list.is_on_list(entry) ) {
     debugf("Entry_map::remove(%p) NOT ON LIST\n", entry);
     entry->debug("NOT ON LIST");
     return;
   }

   list.remove(entry);
}

void
   Entry_map::reset( void )
{  // Remove all entries that are not Entry_const (constant)
   for(size_t i= 0; i<HASH_SIZE; ++i) {
     Hash_entry& list= hash_table[i]; // The hash list
     for(;;) {
       bool all_const= true;
       for(Entry* entry= list.get_tail(); entry; entry= entry->get_prev()) {
         if( entry->is_static() )
           continue;

         all_const= false;
         list.remove(entry);
         break;
       }

       if( all_const )
         break;
     }
   }
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Integer::decode
//
// Purpose-
//       Decode an integer
//
//----------------------------------------------------------------------------
Integer::Value_t                    // The decoded integer
   Integer::decode(                 // Decode integer
     Reader&           reader,      // (INPUT) ReaderIoda
     int               bits)        // Number of size bits in first octet
{
   int mask= (1 << bits) - 1;       // First octet value mask
   int byte= decoder_get(reader);   // The first octet

   size_t value= byte & mask;
   if( value >= (size_t)mask ) {    // Handle continuation
     int SI= 0;                     // (Shift Entry)
     do {
       byte= decoder_get(reader);
       value += ((byte & 0x007F) << SI);
       if( value > UINT32_MAX )
         throw std::range_error("decoder: value");
       SI += 7;
     } while( byte & 0x0080 );
   }

   return (Value_t)value;
}

void
   Integer::encode(                 // Encode integer
     Writer&           writer,      // (OUTPUT Writer Ioda
     Value_t           value,       // The Integer value
     int               stamp,       // First byte encoding bits (ONLY)
     int               bits)        // Number of DATA size bits in stamp
{
   int mask= (1 << bits) - 1;       // First octet value mask
   if( value < (size_t)mask ) {     // If single octet encoding
     writer.put(value |= stamp);
     return;
   }

   writer.put( stamp | mask );      // Encode the first (bit bits) octet
   value -= mask;

   while( value > 0x007F ) {        // Encode middle (7 bit) octets
     writer.put(int(value & 0x007F) | 0x0080);
     value >>= 7;
   }

   writer.put((int)value);          // Encode the final (7 bit) octet
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Property::Property(...)
//
// Purpose-
//       Name/value constructor
//
//----------------------------------------------------------------------------
   Property::Property(              // Name/Value constructor
     const string&     name,        // Name
     const string&     value,       // Value
     octet             et,          // Transfer encoding type
     bool              n_encoded,   // Huffman encoded name?
     bool              v_encoded)   // Huffman encoded value?
:  name(name), value(value), et(et)
,  n_encoded(n_encoded), v_encoded(v_encoded)
{  }

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Property::Property(const Entry&)
//
// Purpose-
//       Construct from Entry
//
//----------------------------------------------------------------------------
   Property::Property(const Entry& I)
{
   name=      I.name;
   value=     I.value ? I.value : "";
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Property::debug
//
// Purpose-
//       Debugging display
//
//----------------------------------------------------------------------------
void
   Property::debug(const char* info) const // Debugging display
{  debugf("Property(%p)::debug(%s)\n", this, info);
   debugf("..name(%s)%s value(%s)%s\n", name.c_str(), n_encoded ? "H" : ""
         , value.c_str(), v_encoded ? "H" : "");
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Property::copy
//       RFC7541::Property::move
//
// Purpose-
//       Copy a Property
//       Move a Property (by copying it)
//
//----------------------------------------------------------------------------
void
   Property::copy(                  // Copy a Property
     const Property&   P)           // Source Property
{
   name=      P.name;
   value=     P.value;
   et=        P.et;
   n_encoded= P.n_encoded;
   v_encoded= P.v_encoded;
}

void
   Property::move(                  // Move a Property
     Property&&         P)          // Source Property
{
   name=      std::move(P.name);
   value=     std::move(P.value);
   et=        P.et;
   n_encoded= P.n_encoded;
   v_encoded= P.v_encoded;
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Properties::debug
//
// Purpose-
//       Debug properties
//
//----------------------------------------------------------------------------
void
   Properties::debug(const char* info) const // Debug properties
{
   debugf("Properties(%p)::debug(%s) [%zd]\n", this, info, size());

   for(size_t i= 0; i < size(); ++i) {
     const Property& P= at(i);
     debugf("[%2zd] et(%d:0x%.2x) %s '%s'%s: '%s'%s\n", i
           , P.et, type_to_mask[P.et], type_to_name[P.et]
           , P.name.c_str(), P.n_encoded ? "(H)" : ""
           , P.value.c_str(), P.v_encoded ? "(H)" : ""
           );
   }
}

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Property::operator==
//
// Purpose-
//       Equality comparison operator
//
// Implementation notes-
//       This method is used for comparing encoded Properties to their decoded
//       counterparts. Only the name and value are compared.
//
//----------------------------------------------------------------------------
bool
   Property::operator==(const Property& rhs) const
{  return name == rhs.name && value == rhs.value; }

//----------------------------------------------------------------------------
//
// Method-
//       RFC7541::Property::operator Entry
//
// Purpose-
//       Cast operator
//
//----------------------------------------------------------------------------
   Property::operator Entry( void ) const
{
   Entry entry(*this);
   return entry;
}

//----------------------------------------------------------------------------
//
// (Static) subroutine-
//       RFC7541::debug
//
// Purpose-
//       Debugging display
//
//----------------------------------------------------------------------------
void
   debug(const char* info) // Debugging display
{
   debugf("RFC7541::debug(%s)\n", info);

   // Display storage sizes
   debugf("%'4zd= sizeof Entry\n", sizeof(Entry));
   debugf("%'4zd= sizeof Entry_const\n", sizeof(Entry_const));
   debugf("%'4zd= sizeof Entry_map\n", sizeof(Entry_map));
   debugf("%'4zd= sizeof Integer\n", sizeof(Integer));
   debugf("%'4zd= sizeof Property\n", sizeof(Property));
   debugf("%'4zd= sizeof Properties\n", sizeof(Properties));
   debugf("%'4zd= sizeof Huff\n", sizeof(Huff));
   debugf("%'4zd= sizeof Pack\n", sizeof(Pack));

#if 0
   #pragma GCC diagnostic push
   #pragma GCC diagnostic ignored "-Winvalid-offsetof"
   debugf("%'4zd= offsetof Entry::name\n", offsetof(Entry, name));
   debugf("%'4zd= offsetof Entry::value\n", offsetof(Entry, value));
   debugf("%'4zd= offsetof Entry::index\n", offsetof(Entry, index));
   debugf("%'4zd= offsetof Entry::_002C\n", offsetof(Entry, _002C));
   #pragma GCC diagnostic pop
#endif

   // Debug decode_index
   debugf("\ndecode_index:\n");
   for(int i= 0; i<DECODE_INDEX_DIM; ++i) {
     const Bits7541& X= decode_index[i];
     debugf("[%3d]: {%3d, %2d, %.8x, %.8x}\n", i, X.min_index, X.bits
           , X.min_encode, X.max_encode);
   }

   // Debug decode_table
   debugf("\ndecode_table:\n");
   for(int i= 0; i<DECODE_TABLE_DIM; ++i) {
     const Huff7541& T= decode_table[i];
     debugf("[%3d]: {%3d, %2d, 0x%.8x} '%c'\n", i, T.decode, T.bits, T.encode
           , T.decode < 256 && isprint(T.decode) ? T.decode : '~');
   }

   // Debug encode_table
   debugf("\nencode_table:\n");
   for(int i= 0; i<ENCODE_TABLE_DIM; ++i) {
     const Huff7541& T= encode_table[i];
     debugf("[%3d]: {%3d, %2d, 0x%.8x} '%c'\n", i, T.decode, T.bits, T.encode
           , T.decode < 256 && isprint(T.decode) ? T.decode : '~');
   }

   // Debug static_entry
   debugf("\nstatic_entry:\n");
   for(int i= 1; i<STATIC_ENTRY_DIM; ++i) {
     const Entry_const& X= static_entry[i];
     debugf("[%3d]: {%s, %s}\n", i, X.name, X.value);
   }
}

//----------------------------------------------------------------------------
//
// (Static) utility subroutine-
//       RFC7541::load_properties
//
// Purpose-
//       Properties loader
//
// Implementation notes-
//       Intent is to make this a test case Properties loader
//       Right now it's scaffolded.
//
//----------------------------------------------------------------------------
Properties                          // The Properties
   load_properties( void )          // Load Properties, parameters TBD
{
   debugf("RFC7541::load_properties()\n");

   Properties properties;
   properties.append("alpha", "beta");
   properties.append("beta", "alpha");
   properties.append("what-the", "hey");
   properties.append("does-this", "work?");

   return properties;
}
}  // Namespace RFC7541
